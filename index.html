<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hockey Stats Game - Dashboard Analytics</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f1f5f9;
            color: #334155;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            position: fixed;
            top: 0;
            left: 0;
        }

        .dashboard-container {
            display: grid;
            grid-template-columns: 15% 1fr;
            grid-template-rows: 60px 1fr;
            height: 100vh;
            gap: 0;
        }

        /* Top Header - Spans both columns */
        .dashboard-header {
            grid-column: 1 / -1;
            background: linear-gradient(135deg, #0891b2 0%, #0e7490 100%);
            padding: 0 24px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            height: 60px;
        }

        .header-title {
            font-size: 20px;
            font-weight: 700;
            color: #ffffff;
            letter-spacing: -0.5px;
        }

        .header-instructions {
            font-size: 13px;
            color: rgba(255, 255, 255, 0.9);
            font-weight: 500;
        }

        /* Left Sidebar - Score Dashboard */
        .score-sidebar {
            background: #ffffff;
            border-right: 1px solid #e2e8f0;
            padding: 16px 12px 12px 12px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            overflow-y: hidden;
        }

        /* Score Card with Progress Bar Visualization */
        .score-card {
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            padding: 10px;
            position: relative;
            overflow: hidden;
        }

        .score-info-btn {
            position: absolute;
            top: 12px;
            right: 12px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #0891b2;
            color: #ffffff;
            border: none;
            cursor: pointer;
            font-size: 12px;
            font-weight: 700;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 200ms ease;
        }

        .score-info-btn:hover {
            background: #0e7490;
            transform: scale(1.1);
        }

        .score-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: linear-gradient(90deg, #06b6d4 0%, #0891b2 100%);
            transition: all 800ms cubic-bezier(0.4, 0, 0.2, 1);
        }

        .score-label {
            font-size: 10px;
            font-weight: 600;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            margin-bottom: 6px;
        }

        .score-display-container {
            position: relative;
        }

        .score-value {
            font-size: 24px;
            font-weight: 800;
            color: #0891b2;
            line-height: 1;
            transition: all 800ms cubic-bezier(0.4, 0, 0.2, 1);
        }

        .score-max {
            display: none;
        }

        /* Progress Bar Visualization */
        .score-progress-container {
            margin-top: 6px;
            position: relative;
            height: 4px;
            background: #e2e8f0;
            border-radius: 2px;
            overflow: hidden;
        }

        .score-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #06b6d4 0%, #0e7490 100%);
            border-radius: 2px;
            transition: background 300ms ease;
        }

        .score-percentage {
            display: none;
        }

        /* Score range color transitions */
        .score-progress-bar.excellent {
            background: linear-gradient(90deg, #0891b2 0%, #0e7490 100%);
        }

        .score-progress-bar.good {
            background: linear-gradient(90deg, #06b6d4 0%, #0891b2 100%);
        }

        .score-progress-bar.average {
            background: linear-gradient(90deg, #14b8a6 0%, #0d9488 100%);
        }

        .score-progress-bar.low {
            background: linear-gradient(90deg, #64748b 0%, #475569 100%);
        }

        /* Delta indicator (smooth, non-jumping) */
        .score-delta {
            position: absolute;
            top: -8px;
            right: 0;
            font-size: 14px;
            font-weight: 700;
            padding: 4px 10px;
            border-radius: 6px;
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 300ms ease, transform 300ms ease;
        }

        .score-delta.show {
            opacity: 1;
            transform: translateY(0);
        }

        .score-delta.positive {
            background: #d1fae5;
            color: #065f46;
        }

        .score-delta.negative {
            background: #fee2e2;
            color: #991b1b;
        }

        /* Hints Card */
        .hints-card {
            background: #ffffff;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            padding: 10px;
        }

        .hints-card.hidden {
            display: none;
        }

        .hints-indicator {
            display: flex;
            gap: 6px;
            margin-top: 8px;
            justify-content: center;
        }

        .hint-dot {
            flex: 1;
            height: 6px;
            background: #e2e8f0;
            border-radius: 3px;
            transition: background 300ms ease;
        }

        .hint-dot.used {
            background: #94a3b8;
        }

        /* Input in Sidebar */
        .sidebar-input-group {
            background: #ffffff;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            padding: 10px;
        }

        .sidebar-input-group.hidden {
            display: none;
        }

        .sidebar-input-group input {
            width: 100%;
            padding: 6px 8px;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            outline: none;
            transition: all 300ms ease;
            margin-bottom: 6px;
        }

        .sidebar-input-group input:focus {
            border-color: #0891b2;
            box-shadow: 0 0 0 3px rgba(8, 145, 178, 0.1);
        }

        .sidebar-input-group input.correct {
            border-color: #10b981;
            background: #f0fdf4;
        }

        .sidebar-input-group input.incorrect {
            border-color: #ef4444;
            animation: shake 600ms ease;
        }

        .sidebar-input-group .btn {
            width: 100%;
            padding: 6px;
            font-size: 12px;
        }

        /* Main Content Area */
        .main-content {
            background: #f8fafc;
            padding: 12px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .content-card {
            background: #ffffff;
            border: 1px solid #e2e8f0;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }


        /* Table Container - Fixed Height with Internal Scroll */
        .table-wrapper {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
        }

        .stats-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
        }

        .stats-table th {
            background: #f8fafc;
            color: #64748b;
            font-weight: 600;
            text-align: center;
            padding: 4px 6px;
            border-bottom: 2px solid #e2e8f0;
            position: sticky;
            top: 0;
            z-index: 10;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.2px;
        }

        .stats-table td {
            padding: 4px 6px;
            text-align: center;
            border-bottom: 1px solid #f1f5f9;
            color: #334155;
            font-weight: 500;
            font-size: 11px;
        }

        /* NHL rows: Season column - Darker cyan to match NHL stats */
        .stats-table tbody tr.nhl-row td:nth-child(1) {
            background: linear-gradient(135deg, #bae6fd 0%, #a5f3fc 100%);
            font-weight: 700;
            border-right: 2px solid #0891b2;
            border-top: 1px solid #0891b2;
            border-bottom: 1px solid #0891b2;
        }

        /* Junior rows: Season column - Lighter slate to match junior stats */
        .stats-table tbody tr.junior-row td:nth-child(1) {
            background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%);
            font-weight: 700;
            border-right: 2px solid #94a3b8;
            border-top: 1px dashed #94a3b8;
            border-bottom: 1px dashed #94a3b8;
        }

        /* League column base */
        .stats-table tbody td.league-col {
            font-weight: 700;
            text-align: center;
            font-size: 12px;
        }

        /* NHL rows: League column */
        .stats-table tbody tr.nhl-row td.league-col {
            background: linear-gradient(135deg, #a5f3fc 0%, #67e8f9 100%);
            color: #0c4a6e;
            font-weight: 700;
            border-right: 2px solid #0891b2;
            border-top: 1px solid #0891b2;
            border-bottom: 1px solid #0891b2;
        }

        /* Junior rows: League column */
        .stats-table tbody tr.junior-row td.league-col {
            background: linear-gradient(135deg, #e2e8f0 0%, #cbd5e1 100%);
            color: #334155;
            font-weight: 700;
            border-right: 2px solid #94a3b8;
            border-top: 1px dashed #94a3b8;
            border-bottom: 1px dashed #94a3b8;
        }

        /* NHL rows: Team column - Cyan gradient to match NHL row */
        .stats-table tbody tr.nhl-row td.team-col {
            background: linear-gradient(135deg, #cffafe 0%, #a5f3fc 100%);
            font-weight: 600;
            border-right: 2px solid #0891b2;
            border-top: 1px solid #0891b2;
            border-bottom: 1px solid #0891b2;
            padding: 4px 8px;
            white-space: nowrap;
            max-width: 150px;
        }

        /* Junior rows: Team column - Slate gradient to match junior row */
        .stats-table tbody tr.junior-row td.team-col {
            background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%);
            font-weight: 600;
            border-right: 2px solid #94a3b8;
            border-top: 1px dashed #94a3b8;
            border-bottom: 1px dashed #94a3b8;
            padding: 4px 8px;
            white-space: nowrap;
            max-width: 150px;
        }

        /* Team column header */
        .stats-table th.team-col {
            max-width: 150px;
            white-space: nowrap;
        }

        /* NHL rows: Primary cyan gradient, solid borders */
        .stats-table tbody tr.nhl-row td:nth-child(4),
        .stats-table tbody tr.nhl-row td:nth-child(5),
        .stats-table tbody tr.nhl-row td:nth-child(6),
        .stats-table tbody tr.nhl-row td:nth-child(7),
        .stats-table tbody tr.nhl-row td:nth-child(8),
        .stats-table tbody tr.nhl-row td:nth-child(9) {
            background: linear-gradient(135deg, #e0f2fe 0%, #bae6fd 100%);
            border-top: 1px solid #0891b2;
            border-bottom: 1px solid #0891b2;
        }

        /* Junior rows: Lighter slate gradient, dashed borders */
        .stats-table tbody tr.junior-row td:nth-child(4),
        .stats-table tbody tr.junior-row td:nth-child(5),
        .stats-table tbody tr.junior-row td:nth-child(6),
        .stats-table tbody tr.junior-row td:nth-child(7),
        .stats-table tbody tr.junior-row td:nth-child(8),
        .stats-table tbody tr.junior-row td:nth-child(9) {
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            border-top: 1px dashed #94a3b8;
            border-bottom: 1px dashed #94a3b8;
        }

        .stats-table tbody td:nth-child(9) {
            border-right: 2px solid #0891b2;
        }

        /* Playoff columns - Darker cyan gradient for NHL */
        .stats-table tbody tr.nhl-row td.playoff-col {
            background: linear-gradient(135deg, #a5f3fc 0%, #67e8f9 100%);
            border-top: 1px solid #0891b2;
            border-bottom: 1px solid #0891b2;
        }

        /* Playoff columns - Lighter slate for junior, dashed */
        .stats-table tbody tr.junior-row td.playoff-col {
            background: linear-gradient(135deg, #e2e8f0 0%, #cbd5e1 100%);
            border-top: 1px dashed #94a3b8;
            border-bottom: 1px dashed #94a3b8;
        }

        .stats-table tbody tr:hover {
            background: #f8fafc;
        }

        .stats-table tbody tr:nth-child(even) {
            background: #fefefe;
        }

        .hidden {
            display: none;
        }

        .reveal-animation {
            animation: reveal 500ms ease;
        }

        @keyframes reveal {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }


        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-8px); }
            20%, 40%, 60%, 80% { transform: translateX(8px); }
        }

        .btn {
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 200ms ease;
            outline: none;
        }

        .btn-primary {
            background: #0891b2;
            color: #ffffff;
        }

        .btn-primary:hover:not(:disabled) {
            background: #0e7490;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(8, 145, 178, 0.3);
        }

        .btn-hint {
            background: linear-gradient(135deg, #f97316 0%, #ea580c 100%);
            color: #ffffff;
            border: 2px solid #c2410c;
        }

        .btn-hint:hover:not(:disabled) {
            background: linear-gradient(135deg, #ea580c 0%, #c2410c 100%);
            border-color: #9a3412;
            box-shadow: 0 4px 12px rgba(249, 115, 22, 0.4);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn:active:not(:disabled) {
            transform: translateY(0);
        }

        /* Multiple Choice Grid in Sidebar */
        .player-choices {
            background: #ffffff;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            padding: 10px;
            display: grid;
            grid-template-columns: 1fr;
            gap: 6px;
        }

        .player-choices.hidden {
            display: none;
        }

        /* Restart Card */
        .restart-card {
            background: #ffffff;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            padding: 10px;
            margin-top: auto;
        }

        .restart-card .btn {
            width: 100%;
        }

        .player-choice-btn {
            padding: 6px 8px;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            background: #ffffff;
            color: #334155;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 200ms ease;
            outline: none;
            text-align: left;
        }

        .player-choice-btn:hover:not(:disabled) {
            background: #f8fafc;
            border-color: #cbd5e1;
            transform: translateX(2px);
        }

        .player-choice-btn.correct-answer {
            background: #d1fae5;
            border-color: #10b981;
            color: #065f46;
        }

        .player-choice-btn.wrong-answer {
            background: #fee2e2;
            border-color: #ef4444;
            color: #991b1b;
            animation: shake 600ms ease;
        }

        .player-choice-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        /* Round Counter */
        .round-counter {
            background: #ffffff;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            padding: 8px 10px;
            text-align: center;
        }

        .round-label {
            font-size: 9px;
            font-weight: 600;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            margin-bottom: 2px;
        }

        .round-value {
            font-size: 16px;
            font-weight: 800;
            color: #0891b2;
        }

        .round-progress-container {
            margin-top: 6px;
            height: 4px;
            background: #e2e8f0;
            border-radius: 2px;
            overflow: hidden;
        }

        .round-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #0891b2 0%, #0e7490 100%);
            border-radius: 2px;
            transition: width 400ms ease;
        }

        /* Success Modal */
        .success-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.3);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            transition: opacity 300ms ease;
        }

        .success-modal.show {
            display: flex;
            opacity: 1;
        }

        .success-modal.hiding {
            opacity: 0;
        }

        .success-content {
            background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);
            border: 3px solid #10b981;
            border-radius: 16px;
            padding: 40px 60px;
            text-align: center;
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.3);
            transform: scale(0.8);
            opacity: 0;
            transition: all 400ms cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .success-modal.show .success-content {
            transform: scale(1);
            opacity: 1;
        }

        .success-modal.hiding .success-content {
            transform: scale(0.95);
            opacity: 0;
            transition: all 300ms ease;
        }

        .success-title {
            font-size: 32px;
            font-weight: 800;
            color: #065f46;
            margin-bottom: 16px;
        }

        .success-player {
            font-size: 24px;
            font-weight: 700;
            color: #047857;
            margin-bottom: 12px;
        }

        .success-score {
            font-size: 18px;
            font-weight: 600;
            color: #059669;
        }

        /* Final Score Modal */
        .final-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            opacity: 0;
            transition: opacity 300ms ease;
        }

        .final-modal.show {
            display: flex;
            opacity: 1;
        }

        .final-content {
            background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
            border: 4px solid #0891b2;
            border-radius: 20px;
            padding: 40px 50px;
            text-align: center;
            box-shadow: 0 16px 64px rgba(0, 0, 0, 0.4);
            transform: scale(0.8);
            opacity: 0;
            transition: all 400ms cubic-bezier(0.34, 1.56, 0.64, 1);
            min-width: 500px;
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .final-modal.show .final-content {
            transform: scale(1);
            opacity: 1;
        }

        .final-title {
            font-size: 36px;
            font-weight: 900;
            color: #0c4a6e;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .final-grade {
            font-size: 56px;
            font-weight: 900;
            margin-bottom: 16px;
        }

        .final-grade.grade-a-plus { color: #10b981; }
        .final-grade.grade-a { color: #059669; }
        .final-grade.grade-b { color: #0891b2; }
        .final-grade.grade-c { color: #f59e0b; }
        .final-grade.grade-d { color: #f97316; }
        .final-grade.grade-f { color: #ef4444; }

        .final-scores {
            margin: 20px 0;
        }

        .final-score-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 20px;
            margin: 8px 0;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 10px;
            border: 2px solid rgba(8, 145, 178, 0.3);
        }

        .final-score-label {
            font-size: 16px;
            font-weight: 600;
            color: #0c4a6e;
        }

        .final-score-value {
            font-size: 24px;
            font-weight: 900;
            color: #0891b2;
        }

        .final-percentage {
            font-size: 40px;
            font-weight: 900;
            color: #0891b2;
            margin: 16px 0;
        }

        .final-breakdown {
            margin: 24px 0;
            text-align: left;
        }

        .breakdown-title {
            font-size: 18px;
            font-weight: 700;
            color: #0c4a6e;
            margin-bottom: 12px;
            text-align: center;
        }

        .breakdown-list {
            background: rgba(255, 255, 255, 0.5);
            border-radius: 10px;
            padding: 12px;
        }

        .breakdown-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            margin: 4px 0;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 6px;
            font-size: 13px;
        }

        .breakdown-player {
            font-weight: 600;
            color: #0c4a6e;
            flex: 1;
        }

        .breakdown-hints {
            color: #64748b;
            font-size: 12px;
            margin-right: 12px;
        }

        .breakdown-score {
            font-weight: 700;
            color: #0891b2;
        }

        .breakdown-score.perfect {
            color: #10b981;
        }

        #final-new-game-btn {
            margin-top: 20px;
            width: 100%;
            font-size: 16px;
            padding: 14px;
        }

        /* Game Info Modal */
        .game-info-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .game-info-modal.show {
            display: flex;
        }

        .game-info-content {
            background: #ffffff;
            border-radius: 12px;
            padding: 24px;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }

        .game-info-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .game-info-title {
            font-size: 18px;
            font-weight: 700;
            color: #334155;
        }

        .game-info-close {
            background: none;
            border: none;
            font-size: 24px;
            color: #94a3b8;
            cursor: pointer;
            line-height: 1;
        }

        .game-info-close:hover {
            color: #334155;
        }

        .game-info-item {
            display: flex;
            justify-content: space-between;
            padding: 12px 0;
            border-bottom: 1px solid #f1f5f9;
        }

        .game-info-item:last-child {
            border-bottom: none;
        }

        .game-info-label {
            color: #64748b;
            font-weight: 500;
        }

        .game-info-value {
            color: #334155;
            font-weight: 700;
        }

        /* Message Toast - In Sidebar Area */
        .message {
            position: fixed;
            top: 80px;
            left: 20px;
            max-width: calc(15% - 40px);
            padding: 12px 16px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 13px;
            opacity: 0;
            transition: opacity 300ms ease;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .message.show {
            opacity: 1;
        }

        .message.success {
            background: #d1fae5;
            color: #065f46;
            border: 1px solid #10b981;
        }

        .message.error {
            background: #fee2e2;
            color: #991b1b;
            border: 1px solid #ef4444;
        }

        .message.info {
            background: #dbeafe;
            color: #1e40af;
            border: 1px solid #3b82f6;
        }

        /* Right Sidebar */
        .right-sidebar {
            background: #ffffff;
            border-left: 1px solid #e2e8f0;
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            overflow-y: auto;
        }

        .right-sidebar-section {
            background: #ffffff;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            padding: 10px;
        }

        .right-sidebar-title {
            font-size: 11px;
            font-weight: 700;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            margin-bottom: 8px;
        }

        /* Room Info */
        .room-info {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .room-code {
            font-size: 12px;
            font-weight: 700;
            color: #0891b2;
            letter-spacing: 1px;
            text-align: center;
            padding: 4px;
            background: linear-gradient(135deg, #e0f2fe 0%, #bae6fd 100%);
            border-radius: 4px;
        }

        .room-players-count {
            font-size: 9px;
            color: #64748b;
            text-align: center;
        }

        /* Leaderboard */
        .leaderboard-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .leaderboard-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            border-radius: 8px;
            border: 2px solid #e2e8f0;
        }

        .leaderboard-item.current-user {
            background: linear-gradient(135deg, #e0f2fe 0%, #bae6fd 100%);
            border-color: #0891b2;
        }

        .leaderboard-item.completed {
            background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);
            border-color: #10b981;
        }

        .leaderboard-rank {
            font-size: 16px;
            font-weight: 800;
            color: #64748b;
            min-width: 24px;
        }

        .leaderboard-item.current-user .leaderboard-rank {
            color: #0891b2;
        }

        .leaderboard-name {
            flex: 1;
            font-size: 13px;
            font-weight: 600;
            color: #334155;
        }

        .leaderboard-hints {
            font-size: 10px;
            color: #64748b;
            margin-right: 6px;
        }

        .leaderboard-score {
            font-size: 16px;
            font-weight: 800;
            color: #0891b2;
        }

        /* Timer Display */
        .timer-display {
            background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%);
            border: 2px solid #ef4444;
            border-radius: 8px;
            padding: 12px;
            text-align: center;
        }

        .timer-value {
            font-size: 28px;
            font-weight: 900;
            color: #ef4444;
            line-height: 1;
        }

        .timer-label {
            font-size: 9px;
            color: #991b1b;
            margin-top: 4px;
            font-weight: 600;
        }

        /* Game Status */
        .game-status {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            padding: 4px 0;
        }

        .status-label {
            color: #64748b;
            font-weight: 500;
        }

        .status-value {
            color: #334155;
            font-weight: 700;
        }

        /* Chat */
        .chat-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
            flex: 1;
            min-height: 0;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 6px;
            min-height: 150px;
            max-height: 250px;
        }

        .chat-message {
            font-size: 10px;
            padding: 6px 8px;
            background: #f8fafc;
            border-radius: 6px;
            border: 1px solid #e2e8f0;
        }

        .chat-message-user {
            font-weight: 700;
            color: #0891b2;
            margin-right: 4px;
        }

        .chat-message-text {
            color: #334155;
        }

        .chat-input-group {
            display: flex;
            gap: 6px;
        }

        .chat-input {
            flex: 1;
            padding: 6px 8px;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            font-size: 11px;
            outline: none;
        }

        .chat-input:focus {
            border-color: #0891b2;
        }

        .chat-send-btn {
            padding: 6px 10px;
            background: #0891b2;
            color: #ffffff;
            border: none;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
        }

        .chat-send-btn:hover {
            background: #0e7490;
        }

        /* Scrollbar Styling */
        .table-wrapper::-webkit-scrollbar,
        .score-sidebar::-webkit-scrollbar,
        .right-sidebar::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        .table-wrapper::-webkit-scrollbar-track,
        .score-sidebar::-webkit-scrollbar-track,
        .right-sidebar::-webkit-scrollbar-track {
            background: #f1f5f9;
        }

        .table-wrapper::-webkit-scrollbar-thumb,
        .score-sidebar::-webkit-scrollbar-thumb,
        .right-sidebar::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 4px;
        }

        .table-wrapper::-webkit-scrollbar-thumb:hover,
        .score-sidebar::-webkit-scrollbar-thumb:hover,
        .right-sidebar::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }
    </style>
</head>
<body>
    <div class="dashboard-container">
        <!-- Top Header -->
        <div class="dashboard-header">
            <div class="header-title">Hockey Stats Analytics</div>
            <div class="header-instructions">Guess the NHL player from their career statistics</div>
        </div>

        <!-- Left Sidebar - Score Dashboard -->
        <div class="score-sidebar">
            <!-- Round Counter -->
            <div class="round-counter">
                <div class="round-label">Round</div>
                <div class="round-value" id="round-value">1 / 5</div>
                <div class="round-progress-container">
                    <div class="round-progress-bar" id="round-progress-bar" style="width: 20%;"></div>
                </div>
            </div>

            <!-- Score Card with Progress Bar -->
            <div class="score-card">
                <button class="score-info-btn" id="score-info-btn" title="Game Info">i</button>
                <div class="score-label">Current Score</div>
                <div class="score-display-container">
                    <span class="score-value" id="score-value">100</span>
                    <span class="score-max">/ 160</span>
                    <div class="score-delta" id="score-delta"></div>
                </div>
                <div class="score-progress-container">
                    <div class="score-progress-bar excellent" id="score-progress">
                        <span class="score-percentage" id="score-percentage">100%</span>
                    </div>
                </div>
            </div>

            <!-- Hints Card -->
            <div class="hints-card" id="hints-card">
                <button class="btn btn-hint" id="hint-btn" style="width: 100%;">Hint (-20): Playoffs</button>
                <div class="hints-indicator">
                    <div class="hint-dot" id="hint-dot-1"></div>
                    <div class="hint-dot" id="hint-dot-2"></div>
                    <div class="hint-dot" id="hint-dot-3"></div>
                </div>
            </div>

            <!-- Input Field in Sidebar -->
            <div class="sidebar-input-group" id="sidebar-input-group">
                <input type="text" id="player-guess" placeholder="Enter player name..." autocomplete="off">
                <button class="btn btn-primary" id="guess-btn">Submit Guess</button>
            </div>

            <!-- Multiple Choice Buttons in Sidebar -->
            <div class="player-choices hidden" id="player-choices">
            </div>

            <!-- Spacer to push restart to bottom -->
            <div style="flex: 1;"></div>

            <!-- Restart Card at Bottom -->
            <div class="restart-card">
                <button class="btn btn-primary" id="restart-btn">New Game</button>
            </div>
        </div>

        <!-- Main Content Area -->
        <div class="main-content">
            <div class="content-card">
                <div class="table-wrapper">
                    <table class="stats-table">
                        <thead>
                            <tr class="header-row">
                                <th class="season-col">Season</th>
                                <th class="league-col">Lge</th>
                                <th class="team-col hidden">Team</th>
                                <th class="regular-season" colspan="6">Regular Season</th>
                                <th class="playoffs hidden" colspan="5">Playoffs</th>
                            </tr>
                            <tr class="subheader-row">
                                <th></th>
                                <th></th>
                                <th class="team-col hidden"></th>
                                <th>GP</th>
                                <th>G</th>
                                <th>A</th>
                                <th>Pts</th>
                                <th>PIM</th>
                                <th>+/-</th>
                                <th class="playoff-col hidden">GP</th>
                                <th class="playoff-col hidden">G</th>
                                <th class="playoff-col hidden">A</th>
                                <th class="playoff-col hidden">Pts</th>
                                <th class="playoff-col hidden">PIM</th>
                            </tr>
                        </thead>
                        <tbody id="stats-body">
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Right Sidebar -->
        <div class="right-sidebar hidden">
            <!-- Room Info -->
            <div class="right-sidebar-section">
                <div class="right-sidebar-title">Room</div>
                <div class="room-info">
                    <div class="room-code">ABC123</div>
                    <div class="room-players-count">4/8 Players</div>
                </div>
                <button class="btn btn-primary" id="start-game-btn" style="width: 100%; margin-top: 8px; display: none;">Start Game</button>
            </div>

            <!-- Timer -->
            <div class="right-sidebar-section" id="timer-section" style="display: none;">
                <div class="right-sidebar-title">Round Timer</div>
                <div class="timer-display">
                    <div class="timer-value" id="timer-display-value">60</div>
                    <div class="timer-label">-1pt per second</div>
                </div>
            </div>

            <!-- Leaderboard -->
            <div class="right-sidebar-section" style="flex: 1; min-height: 0; display: flex; flex-direction: column;">
                <div class="right-sidebar-title">Leaderboard</div>
                <div class="leaderboard-list" style="overflow-y: auto; flex: 1;">
                </div>
            </div>

            <!-- Chat -->
            <div class="right-sidebar-section chat-container" style="flex: 1; min-height: 0;">
                <div class="right-sidebar-title">Chat</div>
                <div class="chat-messages">
                </div>
                <div class="chat-input-group">
                    <input type="text" class="chat-input" placeholder="Message...">
                    <button class="chat-send-btn">Send</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Success Modal -->
    <div class="success-modal" id="success-modal">
        <div class="success-content">
            <div class="success-title">Correct!</div>
            <div class="success-player" id="success-player">Player Name</div>
            <div class="success-score" id="success-score">+50 points</div>
        </div>
    </div>

    <!-- Final Score Modal -->
    <div class="final-modal" id="final-modal">
        <div class="final-content" id="final-content">
            <div class="final-title">Game Complete!</div>
            <div class="final-grade" id="final-grade">A+</div>
            <div class="final-scores">
                <div class="final-score-item">
                    <span class="final-score-label">Your Score</span>
                    <span class="final-score-value" id="final-your-score">450</span>
                </div>
                <div class="final-score-item">
                    <span class="final-score-label">Maximum Possible</span>
                    <span class="final-score-value" id="final-max-score">750</span>
                </div>
            </div>
            <div class="final-percentage" id="final-percentage">60%</div>
            <div class="final-breakdown">
                <div class="breakdown-title">Round Breakdown</div>
                <div class="breakdown-list" id="breakdown-list"></div>
            </div>
            <button class="btn btn-primary" id="final-new-game-btn">New Game</button>
        </div>
    </div>

    <!-- Game Info Modal -->
    <div class="game-info-modal" id="game-info-modal">
        <div class="game-info-content">
            <div class="game-info-header">
                <div class="game-info-title">Game Info</div>
                <button class="game-info-close" id="game-info-close">&times;</button>
            </div>
            <div class="game-info-item">
                <span class="game-info-label">Hint Penalty</span>
                <span class="game-info-value">-20 pts</span>
            </div>
            <div class="game-info-item">
                <span class="game-info-label">Wrong Choice</span>
                <span class="game-info-value">-10 pts</span>
            </div>
            <div class="game-info-item">
                <span class="game-info-label">Correct Bonus</span>
                <span class="game-info-value">+50 pts</span>
            </div>
            <div class="game-info-item">
                <span class="game-info-label">Perfect Score</span>
                <span class="game-info-value">150 pts</span>
            </div>
        </div>
    </div>

    <div class="message" id="game-message"></div>

    <!-- Mode Selection Modal -->
    <div class="game-info-modal" id="mode-modal" style="display: flex; opacity: 1;">
        <div class="game-info-content" style="max-width: 480px; background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%); border: 2px solid #cbd5e1; box-shadow: 0 20px 60px rgba(8, 145, 178, 0.15), 0 8px 32px rgba(0, 0, 0, 0.12);">
            <div class="game-info-header" style="border-bottom: 2px solid #e2e8f0; padding-bottom: 20px; margin-bottom: 24px;">
                <div class="game-info-title" style="font-size: 24px; font-weight: 700; background: linear-gradient(135deg, #0891b2 0%, #0e7490 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;">Select Game Mode</div>
            </div>

            <div style="margin-bottom: 24px;">
                <label style="display: block; font-size: 12px; font-weight: 600; color: #64748b; margin-bottom: 8px; letter-spacing: 0.5px; text-transform: uppercase;">Player Name</label>
                <input type="text" id="player-name-input" placeholder="Enter your name" style="width: 100%; padding: 14px 16px; border: 2px solid #cbd5e1; border-radius: 8px; font-size: 15px; font-weight: 500; color: #334155; background: #ffffff; transition: all 0.2s ease; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.04);" maxlength="20" onfocus="this.style.borderColor='#0891b2'; this.style.boxShadow='0 0 0 3px rgba(8, 145, 178, 0.1)'" onblur="this.style.borderColor='#cbd5e1'; this.style.boxShadow='0 2px 4px rgba(0, 0, 0, 0.04)'">
                <div style="font-size: 11px; color: #94a3b8; margin-top: 6px;">3-20 characters required</div>
            </div>

            <button class="btn btn-primary" id="solo-mode-btn" style="width: 100%; padding: 16px; font-size: 15px; font-weight: 600; border-radius: 8px; margin-bottom: 16px; background: linear-gradient(135deg, #0891b2 0%, #0e7490 100%); border: none; box-shadow: 0 4px 12px rgba(8, 145, 178, 0.25); transition: all 0.2s ease;">
                <span style="display: flex; align-items: center; justify-content: center; gap: 8px;">
                    <span>Play Solo</span>
                    <span style="font-size: 18px;">â†’</span>
                </span>
            </button>

            <div style="display: flex; align-items: center; margin: 24px 0; gap: 12px;">
                <div style="flex: 1; height: 1px; background: linear-gradient(to right, transparent, #cbd5e1, transparent);"></div>
                <span style="font-size: 11px; font-weight: 600; color: #94a3b8; letter-spacing: 1px;">OR PLAY ONLINE</span>
                <div style="flex: 1; height: 1px; background: linear-gradient(to left, transparent, #cbd5e1, transparent);"></div>
            </div>

            <div style="background: #ffffff; border: 2px solid #e2e8f0; border-radius: 8px; padding: 16px; margin-bottom: 12px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.03);">
                <div style="display: flex; gap: 12px; align-items: center;">
                    <button class="btn btn-primary" id="create-room-btn" style="flex: 1; padding: 14px; font-size: 14px; font-weight: 600; border-radius: 6px; background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%); border: none; box-shadow: 0 2px 8px rgba(6, 182, 212, 0.2);">Create Room</button>
                    <label style="display: flex; align-items: center; gap: 8px; font-size: 13px; font-weight: 500; color: #64748b; cursor: pointer; padding: 8px 12px; background: #f8fafc; border: 2px solid #e2e8f0; border-radius: 6px; transition: all 0.2s ease;" onmouseover="this.style.background='#f1f5f9'; this.style.borderColor='#cbd5e1'" onmouseout="this.style.background='#f8fafc'; this.style.borderColor='#e2e8f0'">
                        <input type="checkbox" id="private-room-checkbox" style="width: 16px; height: 16px; cursor: pointer; accent-color: #0891b2;">
                        <span>Private</span>
                    </label>
                </div>
            </div>

            <div style="background: #ffffff; border: 2px solid #e2e8f0; border-radius: 8px; padding: 16px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.03);">
                <label style="display: block; font-size: 11px; font-weight: 600; color: #64748b; margin-bottom: 8px; letter-spacing: 0.5px; text-transform: uppercase;">Join Existing Room</label>
                <div style="display: flex; gap: 8px;">
                    <input type="text" id="join-room-input" placeholder="ROOM CODE" style="flex: 1; padding: 12px 14px; border: 2px solid #cbd5e1; border-radius: 6px; font-size: 14px; font-weight: 600; letter-spacing: 2px; text-transform: uppercase; color: #334155; background: #f8fafc; text-align: center; transition: all 0.2s ease;" maxlength="6" onfocus="this.style.borderColor='#0891b2'; this.style.background='#ffffff'; this.style.boxShadow='0 0 0 3px rgba(8, 145, 178, 0.1)'" onblur="this.style.borderColor='#cbd5e1'; this.style.background='#f8fafc'; this.style.boxShadow='none'">
                    <button class="btn btn-primary" id="join-room-btn" style="padding: 12px 24px; font-size: 14px; font-weight: 600; border-radius: 6px; background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%); border: none; box-shadow: 0 2px 8px rgba(6, 182, 212, 0.2);">Join</button>
                </div>
            </div>

            <div id="public-rooms-list" style="max-height: 220px; overflow-y: auto; border: 2px solid #e2e8f0; border-radius: 8px; padding: 12px; margin-top: 12px; display: none; background: #ffffff; box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.02);">
                <div style="font-size: 11px; font-weight: 600; color: #64748b; margin-bottom: 10px; letter-spacing: 0.5px; text-transform: uppercase; padding-bottom: 8px; border-bottom: 1px solid #f1f5f9;">Available Public Rooms</div>
            </div>
        </div>
    </div>

    <!-- PeerJS - Zero Setup P2P -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

    <script>

    // PeerJS Multiplayer Manager with Persistence
    class MultiplayerManager {
        constructor() {
            this.peer = null;
            this.connections = new Map(); // peer connections
            this.roomCode = null;
            this.playerID = null;
            this.playerName = null;
            this.isHost = false;
            this.turnTimer = null;
            this.turnDuration = 60;

            // Game state (host only)
            this.gameState = {
                players: {},
                currentTurn: null,
                turnTimeLeft: 60,
                chatMessages: []
            };
        }

        generateRoomCode() {
            const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
            let code = '';
            for (let i = 0; i < 6; i++) {
                code += chars[Math.floor(Math.random() * chars.length)];
            }
            return code;
        }

        async checkConnectivity() {
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000);
                await fetch('https://www.google.com/favicon.ico', {
                    method: 'HEAD',
                    mode: 'no-cors',
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                return true;
            } catch (err) {
                console.error('[Connectivity Check] Failed:', err.message);
                return false;
            }
        }

        displayConnectionError(message, retryCallback) {
            const roomCodeEl = document.querySelector('.room-code');
            if (roomCodeEl) {
                roomCodeEl.innerHTML = `
                    <div style="color: #ef4444; font-size: 11px; text-align: center;">
                        ${message}
                    </div>
                    <button class="btn btn-primary" onclick="window.location.reload()"
                            style="width: 100%; margin-top: 8px; font-size: 11px; padding: 6px;">
                        Retry Connection
                    </button>
                `;
            }
        }

        clearConnectionError() {
            const roomCodeEl = document.querySelector('.room-code');
            if (roomCodeEl) {
                roomCodeEl.textContent = this.roomCode || 'Connecting...';
            }
        }

        getUserFriendlyError(error) {
            if (!navigator.onLine) {
                return 'No internet connection';
            }
            if (error.message.includes('unavailable-id')) {
                return 'Room ID conflict. Please retry.';
            }
            if (error.message.includes('network') || error.message.includes('peer')) {
                return 'Network error. Check firewall settings.';
            }
            return error.message || 'Connection failed';
        }

        async createRoom(playerName, isPrivate = false) {
            const maxAttempts = 3;
            const backoffDelays = [0, 2000, 5000];

            for (let attempt = 0; attempt < maxAttempts; attempt++) {
                console.log(`[Room Creation] Attempt ${attempt + 1}/${maxAttempts}`);

                if (backoffDelays[attempt] > 0) {
                    await new Promise(resolve => setTimeout(resolve, backoffDelays[attempt]));
                }

                try {
                    const isOnline = await this.checkConnectivity();
                    if (!isOnline) {
                        throw new Error('No internet connection. Check your network and try again.');
                    }

                    const roomCode = await this.createRoomAttempt(playerName, isPrivate);
                    console.log('[Room Creation] Success on attempt', attempt + 1);
                    this.clearConnectionError();
                    return roomCode;

                } catch (error) {
                    console.error(`[Room Creation] Attempt ${attempt + 1} failed:`, error.message);

                    if (attempt === maxAttempts - 1) {
                        const errorMsg = this.getUserFriendlyError(error);
                        this.displayConnectionError(errorMsg);
                        throw new Error(errorMsg);
                    }
                }
            }
        }

        createRoomAttempt(playerName, isPrivate) {
            return new Promise((resolve, reject) => {
                if (this.peer) {
                    this.peer.destroy();
                    this.peer = null;
                }

                this.playerName = playerName;
                this.isHost = true;
                this.isPrivate = isPrivate;

                const chatMessages = document.querySelector('.chat-messages');
                if (chatMessages) chatMessages.innerHTML = '';

                this.roomCode = this.generateRoomCode();
                this.playerID = 'host_' + this.roomCode.toLowerCase();

                this.peer = new Peer(this.playerID, {
                    debug: 2,
                    config: {
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:global.stun.twilio.com:3478' },
                            { urls: 'stun:stun1.l.google.com:19302' },
                            { urls: 'stun:stun2.l.google.com:19302' },
                            {
                                urls: 'turn:openrelay.metered.ca:80',
                                username: 'openrelayproject',
                                credential: 'openrelayproject'
                            },
                            {
                                urls: 'turn:openrelay.metered.ca:443',
                                username: 'openrelayproject',
                                credential: 'openrelayproject'
                            }
                        ],
                        iceTransportPolicy: 'all'
                    },
                    serialization: 'json'
                });

                const timeout = setTimeout(() => {
                    reject(new Error('Connection timeout after 15 seconds'));
                }, 15000);

                this.peer.on('open', (id) => {
                    clearTimeout(timeout);
                    console.log('[PeerJS] Connection opened. ID:', id);

                    const savedState = localStorage.getItem('gameState');
                    if (savedState) {
                        this.gameState = JSON.parse(savedState);
                    } else {
                        this.gameState.players[this.playerID] = {
                            name: playerName,
                            score: 100,
                            round: 1,
                            hintsUsed: 0,
                            completed: false,
                            isHost: true
                        };
                        this.gameState.currentTurn = this.playerID;
                        this.gameState.gameStarted = false;
                    }

                    localStorage.setItem('hostPeerID', this.playerID);
                    localStorage.setItem('roomCode', this.roomCode);
                    this.saveState();

                    this.setupHostListeners();
                    this.updateLeaderboard(this.gameState.players);

                    const startBtn = document.getElementById('start-game-btn');
                    if (startBtn) {
                        startBtn.style.display = 'block';
                        startBtn.onclick = () => this.startGame();
                    }

                    resolve(this.roomCode);
                });

                this.peer.on('error', (err) => {
                    clearTimeout(timeout);
                    console.error('[PeerJS] Error:', err.type, err.message);

                    let userMessage = '';
                    if (err.type === 'unavailable-id') {
                        localStorage.removeItem('hostPeerID');
                        localStorage.removeItem('roomCode');
                        localStorage.removeItem('gameState');
                        userMessage = 'Room ID conflict. Please try creating a new room.';
                    } else if (err.type === 'network') {
                        userMessage = 'Cannot reach server. Check your internet connection.';
                    } else if (err.type === 'peer-unavailable') {
                        userMessage = 'Cannot establish connection. Please check your network.';
                    } else {
                        userMessage = `Connection error: ${err.message || 'Unknown error'}`;
                    }

                    this.displayConnectionError(userMessage);
                    reject(new Error(userMessage));
                });
            });
        }

        startGame() {
            if (!this.isHost || this.gameState.gameStarted) return;

            this.gameState.gameStarted = true;
            this.saveState();

            // Hide start button
            const startBtn = document.getElementById('start-game-btn');
            if (startBtn) startBtn.style.display = 'none';

            // Show timer
            const timerSection = document.getElementById('timer-section');
            if (timerSection) timerSection.style.display = 'block';

            // Start timer loop
            this.startTimerLoop();

            // Broadcast game started
            this.broadcast({
                type: 'gameStarted',
                state: this.gameState
            });
        }

        setupHostListeners() {
            this.peer.on('connection', (conn) => {
                conn.on('open', () => {
                    this.connections.set(conn.peer, conn);

                    // Send current state to new player
                    conn.send({
                        type: 'state',
                        state: this.gameState
                    });
                });

                conn.on('data', (data) => {
                    this.handleMessage(data, conn.peer);
                });

                conn.on('close', () => {
                    // Remove player
                    delete this.gameState.players[conn.peer];
                    this.connections.delete(conn.peer);
                    this.saveState();
                    this.broadcast({ type: 'players', players: this.gameState.players });
                });
            });
        }

        async joinRoom(code, playerName) {
            return new Promise((resolve, reject) => {
                this.roomCode = code.toUpperCase();
                this.playerName = playerName;
                this.isHost = false;

                const hostPeerID = 'host_' + code.toLowerCase();

                // Create unique player ID
                this.playerID = 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

                // Use PeerJS with better config
                this.peer = new Peer(this.playerID, {
                    debug: 2,
                    config: {
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:global.stun.twilio.com:3478' }
                        ]
                    },
                    serialization: 'json'
                });

                this.peer.on('open', () => {
                    let attempts = 0;
                    const maxAttempts = 3;
                    const retryDelays = [5000, 10000, 15000];

                    const attemptConnection = () => {
                        attempts++;
                        const conn = this.peer.connect(hostPeerID, { reliable: true });
                        let connectionTimeout;
                        let connected = false;
                        let iceComplete = false;

                        connectionTimeout = setTimeout(() => {
                            if (!connected || !iceComplete) {
                                conn.close();
                                if (attempts < maxAttempts) {
                                    const delay = retryDelays[attempts - 1] || 15000;
                                    console.log(`Connection attempt ${attempts} failed. Retrying in ${delay/1000}s...`);
                                    setTimeout(attemptConnection, delay);
                                } else {
                                    reject(new Error(`Connection failed after ${maxAttempts} attempts. Host may be offline or network issues detected.`));
                                }
                            }
                        }, 30000);

                        const checkIceState = () => {
                            if (conn.peerConnection) {
                                const pc = conn.peerConnection;
                                if (pc.iceGatheringState === 'complete') {
                                    iceComplete = true;
                                } else if (pc.iceGatheringState === 'gathering') {
                                    setTimeout(checkIceState, 500);
                                }
                            } else {
                                setTimeout(checkIceState, 100);
                            }
                        };
                        checkIceState();

                        conn.on('open', () => {
                            const waitForIce = () => {
                                if (conn.peerConnection && conn.peerConnection.iceGatheringState === 'complete') {
                                    connected = true;
                                    iceComplete = true;
                                    clearTimeout(connectionTimeout);
                                    console.log(`[Connection] Successfully joined room ${code} on attempt ${attempts}`);

                                    conn.send({
                                        type: 'join',
                                        playerID: this.playerID,
                                        playerName: playerName
                                    });

                                    localStorage.setItem('playerID_' + code, this.playerID);
                                    localStorage.setItem('hostPeerID_' + code, hostPeerID);

                                    this.connections.set(hostPeerID, conn);
                                    this.setupPlayerListeners(conn);
                                    resolve();
                                } else if (conn.peerConnection && conn.peerConnection.iceGatheringState === 'gathering') {
                                    setTimeout(waitForIce, 500);
                                } else {
                                    connected = true;
                                    clearTimeout(connectionTimeout);

                                    conn.send({
                                        type: 'join',
                                        playerID: this.playerID,
                                        playerName: playerName
                                    });

                                    localStorage.setItem('playerID_' + code, this.playerID);
                                    localStorage.setItem('hostPeerID_' + code, hostPeerID);

                                    this.connections.set(hostPeerID, conn);
                                    this.setupPlayerListeners(conn);
                                    resolve();
                                }
                            };
                            waitForIce();
                        });

                        conn.on('error', (err) => {
                            connected = true;
                            iceComplete = true;
                            clearTimeout(connectionTimeout);
                            console.error(`[Connection] Attempt ${attempts} error:`, err);
                            if (attempts < maxAttempts) {
                                const delay = retryDelays[attempts - 1] || 15000;
                                console.log(`Retrying in ${delay/1000}s...`);
                                this.displayConnectionError(`Connection failed. Retrying in ${delay/1000}s... (Attempt ${attempts}/${maxAttempts})`);
                                setTimeout(attemptConnection, delay);
                            } else {
                                const errorMsg = `Failed to connect after ${maxAttempts} attempts. Verify room code and host availability.`;
                                this.displayConnectionError(errorMsg);
                                reject(new Error(errorMsg));
                            }
                        });
                    };

                    attemptConnection();
                });

                this.peer.on('error', (err) => {
                    console.error('[PeerJS] Guest error:', err.type, err.message);

                    let userMessage = '';
                    switch(err.type) {
                        case 'peer-unavailable':
                            userMessage = 'Room not found. Check room code and try again.';
                            break;
                        case 'network':
                            userMessage = 'Cannot reach server. Check your internet connection.';
                            break;
                        case 'disconnected':
                            userMessage = 'Lost connection to server. Please rejoin the room.';
                            break;
                        case 'server-error':
                            userMessage = 'Server error. Please try again in a few moments.';
                            break;
                        default:
                            userMessage = `Connection error: ${err.message || 'Unknown error'}`;
                    }

                    this.displayConnectionError(userMessage);
                    reject(new Error(userMessage));
                });
            });
        }

        setupPlayerListeners(conn) {
            conn.on('data', (data) => {
                switch (data.type) {
                    case 'fullSync':
                        this.gameState = data.state;
                        this.updateLeaderboard(data.state.players);
                        if (data.state.chatMessages) {
                            data.state.chatMessages.forEach(msg => {
                                this.addChatMessage(msg.playerName, msg.text, false);
                            });
                        }
                        console.log('[Guest] Full state synced:', this.gameState);
                        break;
                    case 'state':
                        this.gameState = data.state;
                        this.updateLeaderboard(this.gameState.players);
                        this.updateTimer(this.gameState.turnTimeLeft);
                        // Load chat history
                        data.state.chatMessages.forEach(msg => {
                            this.addChatMessage(msg.playerName, msg.text, false);
                        });
                        // Show timer if game started
                        if (data.state.gameStarted) {
                            const timerSection = document.getElementById('timer-section');
                            if (timerSection) timerSection.style.display = 'block';
                        }
                        break;
                    case 'players':
                        this.gameState.players = data.players;
                        this.updateLeaderboard(data.players);
                        break;
                    case 'timer':
                        this.updateTimer(data.timeLeft);
                        break;
                    case 'chat':
                        this.addChatMessage(data.playerName, data.text, false);
                        this.updateLeaderboard(this.gameState.players);
                        break;
                    case 'gameStarted':
                        this.gameState = data.state;
                        this.updateLeaderboard(this.gameState.players);
                        const timerSection = document.getElementById('timer-section');
                        if (timerSection) timerSection.style.display = 'block';
                        break;
                    case 'guessResult':
                        // Trigger guess validation in guest's game instance
                        const gameInstance = window.hockeyGameInstance;
                        if (gameInstance) {
                            const guess = data.guess;
                            if (guess === gameInstance.correctAnswer) {
                                gameInstance.handleCorrectGuess();
                            } else {
                                gameInstance.handleIncorrectGuess();
                            }
                        }
                        break;
                }
            });

            conn.on('close', () => {
                alert('Connection lost to host. Room closed.');
            });
        }

        handleMessage(data, fromPeer) {
            if (!this.isHost) return;

            switch (data.type) {
                case 'join':
                    if (Object.keys(this.gameState.players).length >= 8) {
                        const conn = this.connections.get(data.playerID);
                        if (conn) {
                            conn.send({ type: 'error', message: 'Room full' });
                        }
                        return;
                    }

                    this.gameState.players[data.playerID] = {
                        name: data.playerName,
                        score: 100,
                        round: 1,
                        hintsUsed: 0,
                        completed: false,
                        isHost: false
                    };
                    this.saveState();

                    const newConn = this.connections.get(data.playerID);
                    if (newConn) {
                        newConn.send({
                            type: 'fullSync',
                            state: {
                                players: this.gameState.players,
                                chatMessages: this.gameState.chatMessages || [],
                                currentRound: this.gameState.currentRound || 1,
                                timeLimit: this.gameState.timeLimit || null,
                                gameMode: this.gameState.gameMode || 'unlimited'
                            }
                        });
                    }

                    this.broadcast({ type: 'players', players: this.gameState.players });
                    break;

                case 'chat':
                    const chatMsg = {
                        playerName: this.gameState.players[fromPeer]?.name || 'Unknown',
                        text: data.text,
                        timestamp: Date.now()
                    };
                    this.gameState.chatMessages.push(chatMsg);
                    if (this.gameState.chatMessages.length > 50) {
                        this.gameState.chatMessages.shift();
                    }
                    this.saveState();
                    this.broadcast({ type: 'chat', ...chatMsg });
                    this.addChatMessage(chatMsg.playerName, chatMsg.text, false);
                    break;

                case 'scoreUpdate':
                    if (this.gameState.players[fromPeer]) {
                        this.gameState.players[fromPeer].score = data.score;
                        this.saveState();
                        this.broadcast({ type: 'players', players: this.gameState.players });
                        this.updateLeaderboard(this.gameState.players);
                    }
                    break;

                case 'hintUsed':
                    if (this.gameState.players[fromPeer]) {
                        this.gameState.players[fromPeer].hintsUsed = data.hintsUsed;
                        this.saveState();
                        this.broadcast({ type: 'players', players: this.gameState.players });
                        this.updateLeaderboard(this.gameState.players);
                    }
                    break;

                case 'completed':
                    if (this.gameState.players[fromPeer]) {
                        this.gameState.players[fromPeer].completed = true;
                        this.gameState.players[fromPeer].score = data.score;
                        this.saveState();
                        this.broadcast({ type: 'players', players: this.gameState.players });
                        this.updateLeaderboard(this.gameState.players);
                    }
                    break;

                case 'guess':
                    // Host validates guest's guess and broadcasts result
                    const conn = this.connections.get(fromPeer);
                    if (conn) {
                        conn.send({
                            type: 'guessResult',
                            guess: data.guess,
                            playerID: data.playerID
                        });
                    }
                    break;
            }
        }

        startTimerLoop() {
            if (!this.isHost) return;
            if (this.turnTimer) clearInterval(this.turnTimer);

            this.turnTimer = setInterval(() => {
                this.gameState.turnTimeLeft--;

                if (this.gameState.turnTimeLeft <= 0) {
                    this.passTurnToNext();
                } else {
                    // Apply -1pt penalty to current player
                    if (this.gameState.players[this.gameState.currentTurn]) {
                        this.gameState.players[this.gameState.currentTurn].score =
                            Math.max(0, this.gameState.players[this.gameState.currentTurn].score - 1);
                    }

                    this.saveState();
                    this.broadcast({
                        type: 'timer',
                        timeLeft: this.gameState.turnTimeLeft,
                        currentTurn: this.gameState.currentTurn
                    });
                    this.broadcast({ type: 'players', players: this.gameState.players });

                    // Update host UI
                    this.updateTimer(this.gameState.turnTimeLeft);
                    this.updateLeaderboard(this.gameState.players);
                }
            }, 1000);
        }

        passTurnToNext() {
            if (!this.isHost) return;

            const playerIDs = Object.keys(this.gameState.players);
            const currentIndex = playerIDs.indexOf(this.gameState.currentTurn);
            const nextIndex = (currentIndex + 1) % playerIDs.length;

            this.gameState.currentTurn = playerIDs[nextIndex];
            this.gameState.turnTimeLeft = this.turnDuration;

            this.saveState();
            this.broadcast({
                type: 'timer',
                timeLeft: this.gameState.turnTimeLeft,
                currentTurn: this.gameState.currentTurn
            });

            this.updateTimer(this.gameState.turnTimeLeft);
            this.updateTurnIndicator(this.gameState.currentTurn);
        }

        sendGuess(guess) {
            if (!this.isHost) {
                // Guest sends guess to host for validation
                const hostConn = Array.from(this.connections.values())[0];
                if (hostConn) {
                    hostConn.send({
                        type: 'guess',
                        guess: guess,
                        playerID: this.playerID
                    });
                }
            }
        }

        sendGuess(guess) {
            if (!this.isHost) {
                const hostConn = Array.from(this.connections.values())[0];
                if (hostConn) {
                    hostConn.send({ type: 'guess', guess: guess, playerID: this.playerID });
                }
            }
        }

        sendChatMessage(text) {
            if (!text.trim()) return;

            if (this.isHost) {
                const msg = {
                    playerName: this.playerName,
                    text: text.trim().substring(0, 200),
                    timestamp: Date.now()
                };
                this.gameState.chatMessages.push(msg);
                if (this.gameState.chatMessages.length > 50) {
                    this.gameState.chatMessages.shift();
                }
                this.saveState();
                this.broadcast({ type: 'chat', ...msg });
                this.addChatMessage(msg.playerName, msg.text, false);
            } else {
                // Send to host
                const conn = this.connections.values().next().value;
                if (conn) {
                    conn.send({
                        type: 'chat',
                        text: text.trim().substring(0, 200)
                    });
                }
            }
        }

        updatePlayerScore(newScore) {
            if (this.isHost) {
                this.gameState.players[this.playerID].score = newScore;
                this.saveState();
                this.broadcast({ type: 'players', players: this.gameState.players });
            } else {
                const conn = this.connections.values().next().value;
                if (conn) {
                    conn.send({
                        type: 'scoreUpdate',
                        score: newScore
                    });
                }
            }
        }

        broadcast(data) {
            this.connections.forEach((conn, peerID) => {
                if (conn.open) {
                    try {
                        conn.send(data);
                    } catch (err) {
                        console.error(`Failed to send to ${peerID}:`, err);
                        // Remove failed connection
                        this.connections.delete(peerID);
                    }
                }
            });
        }

        saveState() {
            if (this.isHost) {
                localStorage.setItem('gameState', JSON.stringify(this.gameState));
            }
        }

        updateLeaderboard(players) {
            const leaderboardList = document.querySelector('.leaderboard-list');
            if (!leaderboardList) return;

            const sorted = Object.entries(players).sort((a, b) => b[1].score - a[1].score);
            leaderboardList.innerHTML = '';

            sorted.forEach(([id, player], index) => {
                const item = document.createElement('div');
                let className = 'leaderboard-item';
                if (id === this.playerID) className += ' current-user';
                if (player.completed) className += ' completed';

                item.className = className;

                const hintsText = player.hintsUsed !== undefined ? `${player.hintsUsed}/3 hints` : '';
                const statusText = player.completed ? ' DONE' : '';

                // Create elements using DOM methods (no innerHTML for user data)
                const rankDiv = document.createElement('div');
                rankDiv.className = 'leaderboard-rank';
                rankDiv.textContent = index + 1;

                const nameDiv = document.createElement('div');
                nameDiv.className = 'leaderboard-name';
                nameDiv.textContent = player.name + statusText;

                const hintsDiv = document.createElement('div');
                hintsDiv.className = 'leaderboard-hints';
                hintsDiv.textContent = hintsText;

                const scoreDiv = document.createElement('div');
                scoreDiv.className = 'leaderboard-score';
                scoreDiv.textContent = player.score;

                item.appendChild(rankDiv);
                item.appendChild(nameDiv);
                item.appendChild(hintsDiv);
                item.appendChild(scoreDiv);

                leaderboardList.appendChild(item);
            });

            const roomPlayersCount = document.querySelector('.room-players-count');
            if (roomPlayersCount) {
                roomPlayersCount.textContent = `${Object.keys(players).length}/8 Players`;
            }
        }

        addChatMessage(username, text, save = true) {
            const chatMessages = document.querySelector('.chat-messages');
            if (!chatMessages) return;

            const messageEl = document.createElement('div');
            messageEl.className = 'chat-message';

            const userSpan = document.createElement('span');
            userSpan.className = 'chat-message-user';
            userSpan.textContent = `${this.sanitize(username)}:`;

            const textSpan = document.createElement('span');
            textSpan.className = 'chat-message-text';
            textSpan.textContent = this.sanitize(text);

            messageEl.appendChild(userSpan);
            messageEl.appendChild(textSpan);
            chatMessages.appendChild(messageEl);

            chatMessages.scrollTop = chatMessages.scrollHeight;

            while (chatMessages.children.length > 50) {
                chatMessages.removeChild(chatMessages.firstChild);
            }
        }

        updateTimer(timeLeft) {
            const timerDisplay = document.getElementById('timer-display-value');
            if (timerDisplay) {
                timerDisplay.textContent = timeLeft;
            }
        }

        updateTurnIndicator(currentTurnPlayer) {
            // Not needed for simultaneous mode
        }

        broadcastHintUsed(hintsUsed) {
            if (this.isHost) {
                this.gameState.players[this.playerID].hintsUsed = hintsUsed;
                this.saveState();
                this.broadcast({ type: 'players', players: this.gameState.players });
            } else {
                const conn = this.connections.values().next().value;
                if (conn) {
                    conn.send({
                        type: 'hintUsed',
                        hintsUsed: hintsUsed
                    });
                }
            }
        }

        broadcastCompletion(score) {
            if (this.isHost) {
                this.gameState.players[this.playerID].completed = true;
                this.gameState.players[this.playerID].score = score;
                this.saveState();
                this.broadcast({ type: 'players', players: this.gameState.players });
            } else {
                const conn = this.connections.values().next().value;
                if (conn) {
                    conn.send({
                        type: 'completed',
                        score: score
                    });
                }
            }
        }

        sanitize(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        validatePlayerName(name) {
            if (!name || typeof name !== 'string') return null;

            const trimmed = name.trim();
            // 3-20 chars, letters, numbers, spaces, hyphens, apostrophes only
            if (trimmed.length < 3 || trimmed.length > 20) return null;
            if (!/^[a-zA-Z0-9\s\-']+$/.test(trimmed)) return null;

            return trimmed;
        }

        disconnect() {
            if (this.turnTimer) {
                clearInterval(this.turnTimer);
            }
            if (this.peer) {
                this.peer.destroy();
            }
        }
    }

    // Global multiplayer instance
    window.multiplayerManager = null;
    </script>

    <script type="module">
        import { GAME_CONFIG } from './src/config.js';

        class HockeyGameDashboard {
            constructor() {
                this.score = GAME_CONFIG.INITIAL_SCORE;
                this.roundStartScore = GAME_CONFIG.INITIAL_SCORE;
                this.maxScore = GAME_CONFIG.INITIAL_SCORE + GAME_CONFIG.CORRECT_BONUS;
                this.hintsUsed = 0;
                this.maxHints = GAME_CONFIG.MAX_HINTS;
                this.hintPenalty = GAME_CONFIG.HINT_PENALTY;
                this.correctGuessBonus = GAME_CONFIG.CORRECT_BONUS;
                this.wrongChoicePenalty = 10;
                this.currentPlayer = null;
                this.correctAnswer = '';
                this.gameWon = false;
                this.multipleChoiceShown = false;
                this.guessTimestamps = [];
                this.animatingScore = false;
                this.playersData = null;

                // 5-round game tracking
                this.currentRound = 0;
                this.totalRounds = 5;
                this.maxPossibleScore = 750; // 5 rounds Ã— 150 pts each
                this.selectedPlayers = []; // Pre-selected 5 unique players
                this.roundHistory = []; // Track performance per round

                this.init();
            }

            async init() {
                try {
                    this.scoreValue = document.getElementById('score-value');
                    this.scoreProgress = document.getElementById('score-progress');
                    this.scorePercentage = document.getElementById('score-percentage');
                    this.scoreDelta = document.getElementById('score-delta');
                    this.playerInput = document.getElementById('player-guess');
                    this.guessBtn = document.getElementById('guess-btn');
                    this.hintBtn = document.getElementById('hint-btn');
                    this.messageEl = document.getElementById('game-message');
                    this.statsBody = document.getElementById('stats-body');
                    this.sidebarInputGroup = document.getElementById('sidebar-input-group');
                    this.hintsCard = document.getElementById('hints-card');
                    this.playerChoicesContainer = document.getElementById('player-choices');
                    this.scoreInfoBtn = document.getElementById('score-info-btn');
                    this.gameInfoModal = document.getElementById('game-info-modal');
                    this.gameInfoClose = document.getElementById('game-info-close');
                    this.restartBtn = document.getElementById('restart-btn');
                    this.successModal = document.getElementById('success-modal');
                    this.successPlayer = document.getElementById('success-player');
                    this.successScore = document.getElementById('success-score');
                    this.roundValue = document.getElementById('round-value');
                    this.roundProgressBar = document.getElementById('round-progress-bar');
                    this.finalModal = document.getElementById('final-modal');
                    this.finalContent = document.getElementById('final-content');
                    this.finalYourScore = document.getElementById('final-your-score');
                    this.finalMaxScore = document.getElementById('final-max-score');
                    this.finalPercentage = document.getElementById('final-percentage');
                    this.finalGrade = document.getElementById('final-grade');
                    this.breakdownList = document.getElementById('breakdown-list');
                    this.finalNewGameBtn = document.getElementById('final-new-game-btn');

                    if (!this.scoreValue || !this.playerInput || !this.statsBody) {
                        throw new Error('Critical DOM elements missing');
                    }

                    await this.selectRandomPlayer();
                    this.populateTable();
                    this.setupEventListeners();

                    // Initialize to round 1
                    this.currentRound = 1;
                    this.updateScoreDisplay(true);
                    this.updateRoundDisplay();
                } catch (error) {
                    this.handleFatalError(error);
                }
            }

            handleFatalError(error) {
                console.error('Game initialization failed:', error);
                alert('Game initialization failed. Please refresh the page.');
            }

            async selectRandomPlayer() {
                try {
                    if (!this.playersData) {
                        const { PLAYERS_DATA } = await import('./src/data.js');
                        this.playersData = PLAYERS_DATA;
                    }

                    if (!this.playersData || !this.playersData.length) {
                        throw new Error('No players available');
                    }

                    // If no players selected yet, pre-select 5 unique players
                    if (this.selectedPlayers.length === 0) {
                        this.preSelectPlayers();
                    }

                    // Use current round index to get player (0-indexed)
                    const playerIndex = this.currentRound - 1;
                    if (playerIndex >= 0 && playerIndex < this.selectedPlayers.length) {
                        this.currentPlayer = this.selectedPlayers[playerIndex];
                    } else {
                        // Fallback to random if something goes wrong
                        const randomIndex = Math.floor(Math.random() * this.playersData.length);
                        this.currentPlayer = this.playersData[randomIndex];
                    }

                    this.correctAnswer = this.currentPlayer.name.toLowerCase();
                } catch (error) {
                    console.error('Failed to load player data:', error);
                    throw error;
                }
            }

            preSelectPlayers() {
                // Shuffle all players and pick first 5
                const shuffled = [...this.playersData].sort(() => Math.random() - 0.5);
                this.selectedPlayers = shuffled.slice(0, this.totalRounds);
            }

            createStatsRow(season) {
                const row = document.createElement('tr');
                const plusMinus = season.plus_minus !== null && season.plus_minus !== undefined
                    ? season.plus_minus : '--';

                // Add league-based class to row for styling
                if (season.league === 'NHL') {
                    row.classList.add('nhl-row');
                } else {
                    row.classList.add('junior-row');
                }

                const cells = [
                    { value: season.season, className: '' },
                    { value: season.league, className: 'league-col' },
                    { value: season.team, className: 'team-col hidden' },
                    { value: season.gp, className: '' },
                    { value: season.g, className: '' },
                    { value: season.a, className: '' },
                    { value: season.pts, className: '' },
                    { value: season.pim, className: '' },
                    { value: plusMinus, className: '' },
                    { value: season.playoff_gp || '--', className: 'playoff-col hidden' },
                    { value: season.playoff_g || '--', className: 'playoff-col hidden' },
                    { value: season.playoff_a || '--', className: 'playoff-col hidden' },
                    { value: season.playoff_pts || '--', className: 'playoff-col hidden' },
                    { value: season.playoff_pim || '--', className: 'playoff-col hidden' }
                ];

                cells.forEach(({ value, className }) => {
                    const cell = document.createElement('td');
                    cell.textContent = value;
                    if (className) cell.className = className;
                    row.appendChild(cell);
                });

                return row;
            }

            populateTable() {
                if (!this.currentPlayer) return;
                const allSeasons = this.currentPlayer.seasons
                    .sort((a, b) => a.season.localeCompare(b.season));
                const fragment = document.createDocumentFragment();
                allSeasons.forEach(season => {
                    fragment.appendChild(this.createStatsRow(season));
                });
                this.statsBody.innerHTML = '';
                this.statsBody.appendChild(fragment);
            }

            setupEventListeners() {
                this.guessBtn.addEventListener('click', () => this.handleGuess());
                this.hintBtn.addEventListener('click', () => this.handleHint());
                this.playerInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.handleGuess();
                });
                this.playerInput.addEventListener('input', () => {
                    this.playerInput.classList.remove('incorrect', 'correct');
                });

                // Modal handlers
                this.scoreInfoBtn.addEventListener('click', () => {
                    this.gameInfoModal.classList.add('show');
                });

                this.gameInfoClose.addEventListener('click', () => {
                    this.gameInfoModal.classList.remove('show');
                });

                this.gameInfoModal.addEventListener('click', (e) => {
                    if (e.target === this.gameInfoModal) {
                        this.gameInfoModal.classList.remove('show');
                    }
                });

                // Restart button
                this.restartBtn.addEventListener('click', () => this.resetGame());

                // Final modal New Game button
                this.finalNewGameBtn.addEventListener('click', () => {
                    this.finalModal.classList.remove('show');
                    this.resetGame();
                });
            }

            updateRoundDisplay() {
                this.roundValue.textContent = `${this.currentRound} / ${this.totalRounds}`;

                // Update overall progress bar
                const progressPercentage = (this.currentRound / this.totalRounds) * 100;
                this.roundProgressBar.style.width = `${progressPercentage}%`;
            }

            sanitizeInput(input) {
                if (!input) return '';
                return input.trim().toLowerCase()
                    .replace(GAME_CONFIG.ALLOWED_INPUT_PATTERN, '')
                    .substring(0, GAME_CONFIG.MAX_INPUT_LENGTH);
            }

            isRateLimited() {
                const now = Date.now();
                this.guessTimestamps = this.guessTimestamps.filter(
                    t => now - t < GAME_CONFIG.RATE_LIMIT_WINDOW
                );
                return this.guessTimestamps.length >= GAME_CONFIG.MAX_GUESSES_PER_WINDOW;
            }

            handleGuess() {
                if (this.gameWon) {
                    this.showMessage('You already won! Refresh to play again.', 'info');
                    return;
                }

                if (this.isRateLimited()) {
                    this.showMessage('Too many guesses. Please wait.', 'error');
                    return;
                }

                this.guessTimestamps.push(Date.now());
                const guess = this.sanitizeInput(this.playerInput.value);

                if (!guess) {
                    this.showMessage('Please enter a valid player name', 'error');
                    return;
                }

                // Multiplayer mode: broadcast guess to host for validation
                if (window.multiplayerManager && !window.multiplayerManager.isHost) {
                    window.multiplayerManager.sendGuess(guess);
                    return;
                }

                // Solo mode or host: validate locally
                if (guess === this.correctAnswer) {
                    this.handleCorrectGuess();
                } else {
                    this.handleIncorrectGuess();
                }
            }

            async handleCorrectGuess() {
                this.gameWon = true;
                const delta = this.correctGuessBonus;
                const newScore = this.score + delta;

                // Track round performance
                this.roundHistory.push({
                    round: this.currentRound,
                    player: this.currentPlayer.name,
                    startScore: this.roundStartScore,
                    endScore: newScore,
                    hintsUsed: this.hintsUsed,
                    pointsGained: delta
                });

                this.animateScoreChange(this.score, newScore, delta);
                this.revealAllColumns();

                // Broadcast completion to multiplayer
                if (window.multiplayerManager) {
                    window.multiplayerManager.broadcastCompletion(newScore);

                    // Replace table with waiting screen (multiplayer only)
                    const mainContent = document.querySelector('.main-content');
                    if (mainContent) {
                        mainContent.innerHTML = `
                            <div style="display: flex; align-items: center; justify-content: center; height: 100%; background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%); border-radius: 12px; flex-direction: column; padding: 40px;">
                                <div style="font-size: 36px; font-weight: 900; color: #065f46; margin-bottom: 20px;">Correct!</div>
                                <div style="font-size: 24px; font-weight: 700; color: #047857; margin-bottom: 40px;">${this.currentPlayer.name}</div>
                                <div style="font-size: 18px; color: #059669; margin-bottom: 20px;">+${delta} points</div>
                                <div style="font-size: 14px; color: #047857;">Waiting for other players...</div>
                            </div>
                        `;
                    }
                } else {
                    // Solo mode - proceed to next round after delay
                    this.showMessage(`Correct! +${delta} pts`, 'success');

                    if (this.currentRound < this.totalRounds) {
                        setTimeout(async () => {
                            await this.loadNextPlayer();
                        }, 2000);
                    } else {
                        setTimeout(() => {
                            this.showFinalScore();
                        }, 2000);
                    }
                }
            }

            async loadNextPlayer() {
                // Increment round counter
                this.currentRound++;
                this.updateRoundDisplay();

                // Reset game state for new player
                this.gameWon = false;
                this.hintsUsed = 0;
                this.multipleChoiceShown = false;
                this.guessTimestamps = [];

                // Set new round baseline - current score is 100%
                this.roundStartScore = this.score;
                this.maxScore = this.score + this.correctGuessBonus;

                // Reset UI
                this.playerInput.value = '';
                this.playerInput.classList.remove('correct', 'incorrect');
                this.playerInput.disabled = false;
                this.guessBtn.disabled = false;
                this.hintBtn.disabled = false;

                // Show hints card and input, hide choices
                this.hintsCard.classList.remove('hidden');
                this.sidebarInputGroup.classList.remove('hidden');
                this.playerChoicesContainer.classList.add('hidden');

                // Reset hint dots
                for (let i = 1; i <= 3; i++) {
                    const dot = document.getElementById(`hint-dot-${i}`);
                    if (dot) dot.classList.remove('used');
                }

                // Reset hint button text
                this.updateHintButtonText();

                // Load new player
                await this.selectRandomPlayer();
                this.populateTable();

                // Hide all columns again
                document.querySelectorAll('.team-col, .playoffs, .playoff-col').forEach(el => {
                    el.classList.add('hidden');
                });

                this.messageEl.classList.remove('show');

                // Update progress bar to show 100% at round start
                this.updateScoreDisplay();
            }

            showFinalScore() {
                // Calculate percentage
                const percentage = Math.round((this.score / this.maxPossibleScore) * 100);

                // Calculate grade
                let grade = 'F';
                let gradeClass = 'grade-f';
                if (percentage >= 90) {
                    grade = 'A+';
                    gradeClass = 'grade-a-plus';
                } else if (percentage >= 80) {
                    grade = 'A';
                    gradeClass = 'grade-a';
                } else if (percentage >= 70) {
                    grade = 'B';
                    gradeClass = 'grade-b';
                } else if (percentage >= 60) {
                    grade = 'C';
                    gradeClass = 'grade-c';
                } else if (percentage >= 50) {
                    grade = 'D';
                    gradeClass = 'grade-d';
                }

                // Update final modal content
                this.finalYourScore.textContent = this.score;
                this.finalMaxScore.textContent = this.maxPossibleScore;
                this.finalPercentage.textContent = `${percentage}%`;
                this.finalGrade.textContent = grade;
                this.finalGrade.className = `final-grade ${gradeClass}`;

                // Populate breakdown
                this.breakdownList.innerHTML = '';
                this.roundHistory.forEach(round => {
                    const item = document.createElement('div');
                    item.className = 'breakdown-item';

                    const player = document.createElement('div');
                    player.className = 'breakdown-player';
                    player.textContent = `${round.round}. ${round.player}`;

                    const hints = document.createElement('div');
                    hints.className = 'breakdown-hints';
                    hints.textContent = round.hintsUsed === 0 ? 'Perfect!' : `${round.hintsUsed} hint${round.hintsUsed > 1 ? 's' : ''}`;

                    const score = document.createElement('div');
                    score.className = round.hintsUsed === 0 ? 'breakdown-score perfect' : 'breakdown-score';
                    score.textContent = `+${round.pointsGained}`;

                    item.appendChild(player);
                    item.appendChild(hints);
                    item.appendChild(score);
                    this.breakdownList.appendChild(item);
                });

                // Show final modal
                setTimeout(() => {
                    this.finalModal.classList.add('show');
                }, 500);
            }

            resetGame() {
                this.score = GAME_CONFIG.INITIAL_SCORE;
                this.roundStartScore = GAME_CONFIG.INITIAL_SCORE;
                this.maxScore = GAME_CONFIG.INITIAL_SCORE + GAME_CONFIG.CORRECT_BONUS;
                this.currentRound = 0;
                this.maxPossibleScore = 750;
                this.roundHistory = [];
                this.selectedPlayers = [];
                this.loadNextPlayer();
            }

            handleIncorrectGuess() {
                this.playerInput.classList.add('incorrect');
                setTimeout(() => {
                    this.playerInput.classList.remove('incorrect');
                }, GAME_CONFIG.SHAKE_DURATION);
                this.showMessage('Incorrect! Try again or use a hint.', 'error');
            }

            async handleHint() {
                if (this.gameWon) {
                    this.showMessage('You already won!', 'info');
                    return;
                }

                if (this.hintsUsed >= this.maxHints) {
                    this.showMessage('No more hints available!', 'error');
                    return;
                }

                this.hintsUsed++;
                const delta = -this.hintPenalty;
                const newScore = this.score - this.hintPenalty;

                // Mark hint as used
                const hintDot = document.getElementById(`hint-dot-${this.hintsUsed}`);
                if (hintDot) hintDot.classList.add('used');

                this.animateScoreChange(this.score, newScore, delta);

                // Broadcast hint usage to multiplayer
                if (window.multiplayerManager) {
                    window.multiplayerManager.broadcastHintUsed(this.hintsUsed);
                }

                if (this.hintsUsed === 1) {
                    this.revealPlayoffs();
                    this.showMessage('Playoffs revealed! -20 points', 'info');
                } else if (this.hintsUsed === 2) {
                    this.revealTeam();
                    this.showMessage('Team revealed! -20 points', 'info');
                } else if (this.hintsUsed === 3) {
                    await this.showMultipleChoice();
                    this.showMessage('Choose from 4 players! -20 points', 'info');
                    this.hintBtn.disabled = true;
                }

                // Update hint button text for next hint
                this.updateHintButtonText();
            }

            updateHintButtonText() {
                const hintTexts = [
                    'Hint (-20): Playoffs',
                    'Hint (-20): Teams',
                    'Hint (-20): 4 Choices'
                ];

                if (this.hintsUsed < this.maxHints) {
                    this.hintBtn.textContent = hintTexts[this.hintsUsed];
                } else {
                    this.hintBtn.textContent = 'No Hints Left';
                }
            }

            animateScoreChange(fromScore, toScore, delta) {
                if (this.animatingScore) return;

                this.animatingScore = true;
                const duration = 800;
                const startTime = performance.now();

                // Show delta badge
                this.scoreDelta.textContent = delta > 0 ? `+${delta}` : delta;
                this.scoreDelta.className = `score-delta ${delta > 0 ? 'positive' : 'negative'} show`;

                const animate = (currentTime) => {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);

                    // Easing function for smooth animation
                    const easeProgress = progress < 0.5
                        ? 2 * progress * progress
                        : -1 + (4 - 2 * progress) * progress;

                    const currentScore = Math.round(fromScore + (toScore - fromScore) * easeProgress);
                    this.score = currentScore;
                    this.updateScoreDisplay();

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        this.score = toScore;
                        this.updateScoreDisplay();
                        this.animatingScore = false;

                        // Hide delta badge after animation
                        setTimeout(() => {
                            this.scoreDelta.classList.remove('show');
                        }, 1500);
                    }
                };

                requestAnimationFrame(animate);
            }

            updateScoreDisplay(instant = false) {
                // Progress bar shows: current score / round start score
                // Start round at 100: bar at 100%
                // Use hint to 80: bar at 80%
                // Correct to 130: bar at 130%
                const percentage = (this.score / this.roundStartScore) * 100;

                // Update score value
                this.scoreValue.textContent = this.score;

                // Update progress bar width
                this.scoreProgress.style.width = `${percentage}%`;
                this.scorePercentage.textContent = `${Math.round(percentage)}%`;

                // Update progress bar color based on percentage
                this.scoreProgress.classList.remove('excellent', 'good', 'average', 'low');
                if (percentage >= 100) {
                    this.scoreProgress.classList.add('excellent');
                } else if (percentage >= 80) {
                    this.scoreProgress.classList.add('good');
                } else if (percentage >= 60) {
                    this.scoreProgress.classList.add('average');
                } else {
                    this.scoreProgress.classList.add('low');
                }
            }

            async showMultipleChoice() {
                // Hide hints card and input group
                this.hintsCard.classList.add('hidden');
                this.sidebarInputGroup.classList.add('hidden');

                const choices = await this.generatePlayerChoices();
                this.playerChoicesContainer.innerHTML = '';

                choices.forEach(playerName => {
                    const button = document.createElement('button');
                    button.className = 'player-choice-btn';
                    button.textContent = playerName;
                    button.addEventListener('click', () => this.handleMultipleChoiceClick(playerName, button));
                    this.playerChoicesContainer.appendChild(button);
                });

                this.playerChoicesContainer.classList.remove('hidden');
                this.multipleChoiceShown = true;
            }

            async generatePlayerChoices() {
                const choices = [this.currentPlayer.name];
                const otherPlayers = this.playersData
                    .filter(p => p.name !== this.currentPlayer.name)
                    .map(p => p.name);

                while (choices.length < GAME_CONFIG.MULTIPLE_CHOICE_COUNT && otherPlayers.length > 0) {
                    const randomIndex = Math.floor(Math.random() * otherPlayers.length);
                    choices.push(otherPlayers[randomIndex]);
                    otherPlayers.splice(randomIndex, 1);
                }

                // Shuffle choices
                for (let i = choices.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [choices[i], choices[j]] = [choices[j], choices[i]];
                }

                return choices;
            }

            handleMultipleChoiceClick(playerName, button) {
                if (this.gameWon) return;

                const isCorrect = playerName.toLowerCase() === this.correctAnswer;

                if (isCorrect) {
                    button.classList.add('correct-answer');
                    const allButtons = this.playerChoicesContainer.querySelectorAll('.player-choice-btn');
                    allButtons.forEach(btn => btn.disabled = true);
                    this.handleCorrectGuess();
                } else {
                    // Wrong choice penalty
                    const delta = -this.wrongChoicePenalty;
                    const newScore = this.score + delta;
                    this.animateScoreChange(this.score, newScore, delta);

                    button.classList.add('wrong-answer');
                    button.disabled = true;
                    this.showMessage(`Incorrect! -10 pts`, 'error');
                }
            }

            revealPlayoffs() {
                const playoffHeaders = document.querySelectorAll('.playoffs');
                playoffHeaders.forEach(header => {
                    header.classList.remove('hidden');
                    header.classList.add('reveal-animation');
                });

                const playoffCols = document.querySelectorAll('.playoff-col');
                playoffCols.forEach(col => {
                    col.classList.remove('hidden');
                    col.classList.add('reveal-animation');
                });
            }

            revealTeam() {
                const teamHeaders = document.querySelectorAll('.team-col');
                teamHeaders.forEach(header => {
                    header.classList.remove('hidden');
                    header.classList.add('reveal-animation');
                });
            }

            revealAllColumns() {
                this.revealPlayoffs();
                this.revealTeam();
            }

            showMessage(text, type) {
                this.messageEl.textContent = text;
                this.messageEl.className = `message ${type} show`;

                if (type !== 'success') {
                    setTimeout(() => {
                        this.messageEl.classList.remove('show');
                    }, GAME_CONFIG.MESSAGE_TIMEOUT);
                }
            }
        }

        // Mode Selection & Chat Setup
        document.addEventListener('DOMContentLoaded', () => {
            const modeModal = document.getElementById('mode-modal');
            const soloBtn = document.getElementById('solo-mode-btn');
            const createRoomBtn = document.getElementById('create-room-btn');
            const joinRoomBtn = document.getElementById('join-room-btn');
            const joinRoomInput = document.getElementById('join-room-input');
            const roomCodeEl = document.querySelector('.room-code');
            const chatInput = document.querySelector('.chat-input');
            const chatSendBtn = document.querySelector('.chat-send-btn');

            // Auto-start in solo mode (skip modal)
            modeModal.style.display = 'none';
            const rightSidebar = document.querySelector('.right-sidebar');
            if (rightSidebar) rightSidebar.classList.add('hidden');
            window.multiplayerManager = null;
            window.hockeyGameInstance = new HockeyGameDashboard();

            // Solo mode button (kept for future use)
            soloBtn.addEventListener('click', () => {
                modeModal.style.display = 'none';
                const rightSidebar = document.querySelector('.right-sidebar');
                if (rightSidebar) rightSidebar.classList.add('hidden');

                window.multiplayerManager = null;
                window.hockeyGameInstance = new HockeyGameDashboard();
            });

            // Create room
            createRoomBtn.addEventListener('click', async () => {
                const playerNameInput = document.getElementById('player-name-input');
                let playerName = playerNameInput.value;
                const tempMgr = new MultiplayerManager();
                playerName = tempMgr.validatePlayerName(playerName);

                if (!playerName) {
                    alert('Invalid name. Use 3-20 characters (letters, numbers, spaces, hyphens, apostrophes only).');
                    return;
                }

                // Clean old localStorage data
                const keysToRemove = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && (key.startsWith('playerID_') || key.startsWith('hostPeerID_') || key === 'roomCode' || key === 'gameState')) {
                        keysToRemove.push(key);
                    }
                }
                keysToRemove.forEach(key => localStorage.removeItem(key));

                const isPrivate = document.getElementById('private-room-checkbox').checked;

                try {
                    window.multiplayerManager = tempMgr;
                    const code = await window.multiplayerManager.createRoom(playerName, isPrivate);

                    const rightSidebar = document.querySelector('.right-sidebar');
                    if (rightSidebar) rightSidebar.classList.remove('hidden');

                    roomCodeEl.textContent = code;
                    modeModal.style.display = 'none';

                    window.hockeyGameInstance = new HockeyGameDashboard();
                } catch (error) {
                    alert('Error creating room: ' + error.message);
                }
            });

            // Join room
            joinRoomBtn.addEventListener('click', async () => {
                const code = joinRoomInput.value.trim().toUpperCase();
                if (!code || code.length !== 6) {
                    alert('Please enter a valid 6-character room code');
                    return;
                }

                const playerNameInput = document.getElementById('player-name-input');
                let playerName = playerNameInput.value;
                const tempMgr = new MultiplayerManager();
                playerName = tempMgr.validatePlayerName(playerName);

                if (!playerName) {
                    alert('Invalid name. Use 3-20 characters (letters, numbers, spaces, hyphens, apostrophes only).');
                    return;
                }

                // Clean old localStorage data
                const keysToRemove = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && (key.startsWith('playerID_') || key.startsWith('hostPeerID_') || key === 'roomCode' || key === 'gameState')) {
                        keysToRemove.push(key);
                    }
                }
                keysToRemove.forEach(key => localStorage.removeItem(key));

                try {
                    window.multiplayerManager = tempMgr;
                    await window.multiplayerManager.joinRoom(code, playerName);

                    roomCodeEl.textContent = code;
                    modeModal.style.display = 'none';

                    const rightSidebar = document.querySelector('.right-sidebar');
                    if (rightSidebar) rightSidebar.classList.remove('hidden');

                    const statusValues = document.querySelectorAll('.status-value');
                    if (statusValues[0]) statusValues[0].textContent = 'Multiplayer';

                    window.hockeyGameInstance = new HockeyGameDashboard();
                } catch (error) {
                    alert('Error joining room: ' + error.message);
                }
            });

            // Chat send
            const sendMessage = () => {
                if (!window.multiplayerManager || !chatInput.value.trim()) return;
                window.multiplayerManager.sendChatMessage(chatInput.value);
                chatInput.value = '';
            };

            chatSendBtn.addEventListener('click', sendMessage);
            chatInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') sendMessage();
            });
        });
    </script>
</body>
</html>
